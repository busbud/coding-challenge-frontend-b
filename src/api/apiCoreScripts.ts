import axios, { AxiosError } from "axios";
import createError from "http-errors";

type TRequestHeaders = Record<string, any>;

// NOTE: this would be generated by interrogating the list of
// published interfaces from an api (via swagger) or what have
// you. The intent of this abstraction is to allow the underyling
// URLs which are called to be separated from those invoking them.
//
const endpointUrls: Record<string, string> = {
  // NOTE: version two here is assumed based upon the `Accept` header  definition
  scheduledDeparturesPollV2:
    "x-departures/{origin}/{destination}/{outbound_date}/poll",
  scheduledDeparturesV2: "x-departures/{origin}/{destination}/{outbound_date}",
};

export type TWhitelistedEndpoints =
  | "scheduledDeparturesPollV2"
  | "scheduledDeparturesV2";
export type TCallApiRequest = {
  // Whitelist the know endpoints only
  endpoint: TWhitelistedEndpoints;
  getCustomHeaders?: () => TRequestHeaders;
  method: "GET" | "POST" | "PATCH" | "PUT" | "DELETE" | "HEAD" | "OPTIONS";
  params?: Record<string, any>;
  queryParams?: Array<[string, any]>;
  urlParams?: Record<string, any>;
};

type THandleError = {
  err: AxiosError;
};

export const callApi = async (requestData: TCallApiRequest): Promise<any> => {
  const {
    endpoint,
    getCustomHeaders,
    method,
    params,
    queryParams,
    urlParams,
  } = requestData;
  const host = getHost();
  const url = formatEndpoint(endpoint, urlParams);
  const query = getQueryParams(queryParams);
  const requestHeaders = getHeaders(getCustomHeaders);

  try {
    const response = await axios(`${host}${url}${query}`, {
      data: params,
      headers: requestHeaders,
      method,
      withCredentials: true,
    });

    return response.data;
  } catch (err) {
    await handleError({
      err,
    });
  }
};

export const handleError = (errorData: THandleError): string => {
  const { err } = errorData;
  //eslint-disable-next-line
  console.log(err);
  if (err?.response) {
    throw new Error(err.response.data.message);
  }
  throw err;
};

export const getHost = (): string => {
  const typedHost = process.env.REACT_APP_BUSBUD_API_SERVER;

  if (!typedHost) {
    throw createError(500, "[hostnameMissing] No Hostname Specified", 500);
  }

  return typedHost;
};

export const getQueryParams = (
  queryParams?: Array<[string, string]>
): string => {
  let query = "";
  if (queryParams) {
    query = queryParams
      .map((queryString) => {
        return queryString.join("=");
      })
      .join("&");
    query = `?${query}`;
  }
  return query;
};

export const resolveUrlFromEndpointName = (endpoint: string): string => {
  if (!endpointUrls || !Object.keys(endpointUrls).includes(endpoint)) {
    throw createError(
      400,
      `[unsupportedMethod] ${endpoint} is not currently supported. \n \n Valid Enpoints available: ${Object.keys(
        endpointUrls
      ).join(", ")}`
    );
  }
  return endpointUrls[endpoint];
};
export const formatEndpoint = (
  endpoint: string,
  urlParams?: Record<string, any>
): string => {
  const url = resolveUrlFromEndpointName(endpoint);

  // get all of the params for this url
  const requiredParams = getEndpointParams(url);
  if (!requiredParams) return url;

  if (requiredParams && !urlParams) {
    throw createError(
      400,
      `[paramsMissing] ${url} has required url params, please update your request params`
    );
  }

  const paramKeys = Object.keys(urlParams || {});

  // ensure that all of the required params are present in the provided params;
  let valid = true;
  const missing: string[] = [];
  requiredParams.forEach((key) => {
    if (!paramKeys.includes(key.replace("{", "").replace("}", ""))) {
      valid = false;
      missing.push(key);
    }
  });

  if (!valid) {
    throw createError(
      400,
      `[paramsMissing] ${url} request is missing the following required params from the request: ${missing.join(
        ", "
      )}`
    );
  }

  let formattedUrl = url;
  if (urlParams) {
    paramKeys.forEach((param) => {
      if (urlParams[param] === null) {
        // remove the leading slash so that the entire param is remove
        formattedUrl = formattedUrl.replace(`/{${param}}`, "");
      } else {
        formattedUrl = formattedUrl.replace(`{${param}}`, urlParams[param]);
      }
    });
  }
  return formattedUrl;
};

export const getEndpointParams = (url: string): string[] | null => {
  return url.match(/{[a-zA-Z]+}/g);
};

// NOTE: Linting disabled as HTTP headers don't adhere to the
// established naming conventions
/* eslint-disable @typescript-eslint/naming-convention*/
export const getHeaders = (
  getCustomHeader?: () => { [key: string]: any }
): TRequestHeaders => {
  const baseHeader = getCustomHeader ? getCustomHeader() : {};
  return Object.assign({}, baseHeader, {
    "Content-Type": "application/json",
  });
};
/* eslint-enable @typescript-eslint/naming-convention*/
